/* tslint:disable */
/* eslint-disable */
/**
 * Openfort API
 * Complete Openfort API references and guides can be found at: https://openfort.xyz/docs
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@openfort.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccountListResponse } from '../models';
// @ts-ignore
import { AccountResponse } from '../models';
// @ts-ignore
import { AccountResponseExpandable } from '../models';
// @ts-ignore
import { CancelTransferOwnershipRequest } from '../models';
// @ts-ignore
import { CompleteRecoveryRequest } from '../models';
// @ts-ignore
import { CreateAccountRequest } from '../models';
// @ts-ignore
import { DeployRequest } from '../models';
// @ts-ignore
import { SignPayloadRequest } from '../models';
// @ts-ignore
import { SignPayloadResponse } from '../models';
// @ts-ignore
import { SortOrder } from '../models';
// @ts-ignore
import { StartRecoveryRequest } from '../models';
// @ts-ignore
import { TransactionIntentResponse } from '../models';
// @ts-ignore
import { TransferOwnershipRequest } from '../models';
/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferOwnership: async (id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelTransferOwnership', 'id', id)
            // verify required parameter 'cancelTransferOwnershipRequest' is not null or undefined
            assertParamExists('cancelTransferOwnership', 'cancelTransferOwnershipRequest', cancelTransferOwnershipRequest)
            const localVarPath = `/v1/accounts/{id}/cancel_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRecovery: async (id: string, completeRecoveryRequest: CompleteRecoveryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeRecovery', 'id', id)
            // verify required parameter 'completeRecoveryRequest' is not null or undefined
            assertParamExists('completeRecovery', 'completeRecoveryRequest', completeRecoveryRequest)
            const localVarPath = `/v1/accounts/{id}/complete_recovery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
         * @summary Deploy an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {DeployRequest} deployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAccount: async (id: string, deployRequest: DeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deployAccount', 'id', id)
            // verify required parameter 'deployRequest' is not null or undefined
            assertParamExists('deployAccount', 'deployRequest', deployRequest)
            const localVarPath = `/v1/accounts/{id}/deploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.  Returns the latest 10 transaction intents created by this account.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, expand?: Array<AccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a player.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'player' is not null or undefined
            assertParamExists('getAccounts', 'player', player)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferOwnership: async (id: string, transferOwnershipRequest: TransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestTransferOwnership', 'id', id)
            // verify required parameter 'transferOwnershipRequest' is not null or undefined
            assertParamExists('requestTransferOwnership', 'transferOwnershipRequest', transferOwnershipRequest)
            const localVarPath = `/v1/accounts/{id}/request_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Custodial Accounts only** - Signs the typed repositories value with types repositories structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload: async (id: string, signPayloadRequest: SignPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signPayload', 'id', id)
            // verify required parameter 'signPayloadRequest' is not null or undefined
            assertParamExists('signPayload', 'signPayloadRequest', signPayloadRequest)
            const localVarPath = `/v1/accounts/{id}/sign_payload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecovery: async (id: string, startRecoveryRequest: StartRecoveryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startRecovery', 'id', id)
            // verify required parameter 'startRecoveryRequest' is not null or undefined
            assertParamExists('startRecovery', 'startRecoveryRequest', startRecoveryRequest)
            const localVarPath = `/v1/accounts/{id}/start_recovery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('syncAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}/sync`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransferOwnership(id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransferOwnership(id, cancelTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeRecovery(id: string, completeRecoveryRequest: CompleteRecoveryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeRecovery(id, completeRecoveryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
         * @summary Deploy an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {DeployRequest} deployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployAccount(id: string, deployRequest: DeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployAccount(id, deployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.  Returns the latest 10 transaction intents created by this account.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a player.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(player, limit, skip, order, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTransferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTransferOwnership(id, transferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Custodial Accounts only** - Signs the typed repositories value with types repositories structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignPayloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signPayload(id, signPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecovery(id: string, startRecoveryRequest: StartRecoveryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRecovery(id, startRecoveryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {AccountsApiCancelTransferOwnershipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferOwnership(requestParameters: AccountsApiCancelTransferOwnershipRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.cancelTransferOwnership(requestParameters.id, requestParameters.cancelTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {AccountsApiCompleteRecoveryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRecovery(requestParameters: AccountsApiCompleteRecoveryRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.completeRecovery(requestParameters.id, requestParameters.completeRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
         * @summary Create an account object.
         * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(requestParameters: AccountsApiCreateAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.createAccount(requestParameters.createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
         * @summary Deploy an account.
         * @param {AccountsApiDeployAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAccount(requestParameters: AccountsApiDeployAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.deployAccount(requestParameters.id, requestParameters.deployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount(requestParameters: AccountsApiDisableAccountRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disableAccount(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.  Returns the latest 10 transaction intents created by this account.
         * @summary Get existing account.
         * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(requestParameters: AccountsApiGetAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.getAccount(requestParameters.id, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a player.
         * @param {AccountsApiGetAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(requestParameters: AccountsApiGetAccountsRequest, options?: AxiosRequestConfig): AxiosPromise<AccountListResponse> {
            return localVarFp.getAccounts(requestParameters.player, requestParameters.limit, requestParameters.skip, requestParameters.order, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {AccountsApiRequestTransferOwnershipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferOwnership(requestParameters: AccountsApiRequestTransferOwnershipRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.requestTransferOwnership(requestParameters.id, requestParameters.transferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * **Custodial Accounts only** - Signs the typed repositories value with types repositories structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
         * @summary Sign a given payload
         * @param {AccountsApiSignPayloadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload(requestParameters: AccountsApiSignPayloadRequest, options?: AxiosRequestConfig): AxiosPromise<SignPayloadResponse> {
            return localVarFp.signPayload(requestParameters.id, requestParameters.signPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {AccountsApiStartRecoveryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecovery(requestParameters: AccountsApiStartRecoveryRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.startRecovery(requestParameters.id, requestParameters.startRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
         * @summary Sync account state with the blockchain
         * @param {AccountsApiSyncAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAccount(requestParameters: AccountsApiSyncAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.syncAccount(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelTransferOwnership operation in AccountsApi.
 * @export
 * @interface AccountsApiCancelTransferOwnershipRequest
 */
export interface AccountsApiCancelTransferOwnershipRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiCancelTransferOwnership
     */
    readonly id: string

    /**
     * 
     * @type {CancelTransferOwnershipRequest}
     * @memberof AccountsApiCancelTransferOwnership
     */
    readonly cancelTransferOwnershipRequest: CancelTransferOwnershipRequest
}

/**
 * Request parameters for completeRecovery operation in AccountsApi.
 * @export
 * @interface AccountsApiCompleteRecoveryRequest
 */
export interface AccountsApiCompleteRecoveryRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiCompleteRecovery
     */
    readonly id: string

    /**
     * 
     * @type {CompleteRecoveryRequest}
     * @memberof AccountsApiCompleteRecovery
     */
    readonly completeRecoveryRequest: CompleteRecoveryRequest
}

/**
 * Request parameters for createAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateAccountRequest
 */
export interface AccountsApiCreateAccountRequest {
    /**
     * 
     * @type {CreateAccountRequest}
     * @memberof AccountsApiCreateAccount
     */
    readonly createAccountRequest: CreateAccountRequest
}

/**
 * Request parameters for deployAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeployAccountRequest
 */
export interface AccountsApiDeployAccountRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiDeployAccount
     */
    readonly id: string

    /**
     * 
     * @type {DeployRequest}
     * @memberof AccountsApiDeployAccount
     */
    readonly deployRequest: DeployRequest
}

/**
 * Request parameters for disableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDisableAccountRequest
 */
export interface AccountsApiDisableAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsApiDisableAccount
     */
    readonly id: string
}

/**
 * Request parameters for getAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRequest
 */
export interface AccountsApiGetAccountRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly id: string

    /**
     * 
     * @type {Array<AccountResponseExpandable>}
     * @memberof AccountsApiGetAccount
     */
    readonly expand?: Array<AccountResponseExpandable>
}

/**
 * Request parameters for getAccounts operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountsRequest
 */
export interface AccountsApiGetAccountsRequest {
    /**
     * Specifies the unique player ID (starts with pla_)
     * @type {string}
     * @memberof AccountsApiGetAccounts
     */
    readonly player: string

    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof AccountsApiGetAccounts
     */
    readonly limit?: number

    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof AccountsApiGetAccounts
     */
    readonly skip?: number

    /**
     * Specifies the order in which to sort the results.
     * @type {SortOrder}
     * @memberof AccountsApiGetAccounts
     */
    readonly order?: SortOrder

    /**
     * Specifies the fields to expand in the response.
     * @type {Array<AccountResponseExpandable>}
     * @memberof AccountsApiGetAccounts
     */
    readonly expand?: Array<AccountResponseExpandable>
}

/**
 * Request parameters for requestTransferOwnership operation in AccountsApi.
 * @export
 * @interface AccountsApiRequestTransferOwnershipRequest
 */
export interface AccountsApiRequestTransferOwnershipRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiRequestTransferOwnership
     */
    readonly id: string

    /**
     * 
     * @type {TransferOwnershipRequest}
     * @memberof AccountsApiRequestTransferOwnership
     */
    readonly transferOwnershipRequest: TransferOwnershipRequest
}

/**
 * Request parameters for signPayload operation in AccountsApi.
 * @export
 * @interface AccountsApiSignPayloadRequest
 */
export interface AccountsApiSignPayloadRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiSignPayload
     */
    readonly id: string

    /**
     * 
     * @type {SignPayloadRequest}
     * @memberof AccountsApiSignPayload
     */
    readonly signPayloadRequest: SignPayloadRequest
}

/**
 * Request parameters for startRecovery operation in AccountsApi.
 * @export
 * @interface AccountsApiStartRecoveryRequest
 */
export interface AccountsApiStartRecoveryRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiStartRecovery
     */
    readonly id: string

    /**
     * 
     * @type {StartRecoveryRequest}
     * @memberof AccountsApiStartRecovery
     */
    readonly startRecoveryRequest: StartRecoveryRequest
}

/**
 * Request parameters for syncAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiSyncAccountRequest
 */
export interface AccountsApiSyncAccountRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiSyncAccount
     */
    readonly id: string
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Cancel a pending transfer of ownership.
     * @summary Cancel request to transfer ownership of an account.
     * @param {AccountsApiCancelTransferOwnershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public cancelTransferOwnership(requestParameters: AccountsApiCancelTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).cancelTransferOwnership(requestParameters.id, requestParameters.cancelTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete a recovery process of a recoverable account.
     * @param {AccountsApiCompleteRecoveryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public completeRecovery(requestParameters: AccountsApiCompleteRecoveryRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).completeRecovery(requestParameters.id, requestParameters.completeRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
     * @summary Create an account object.
     * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(requestParameters: AccountsApiCreateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(requestParameters.createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
     * @summary Deploy an account.
     * @param {AccountsApiDeployAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deployAccount(requestParameters: AccountsApiDeployAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deployAccount(requestParameters.id, requestParameters.deployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public disableAccount(requestParameters: AccountsApiDisableAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).disableAccount(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.  Returns the latest 10 transaction intents created by this account.
     * @summary Get existing account.
     * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(requestParameters: AccountsApiGetAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(requestParameters.id, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
     * @summary List accounts of a player.
     * @param {AccountsApiGetAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(requestParameters: AccountsApiGetAccountsRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(requestParameters.player, requestParameters.limit, requestParameters.skip, requestParameters.order, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
     * @summary Request transfer ownership of account.
     * @param {AccountsApiRequestTransferOwnershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public requestTransferOwnership(requestParameters: AccountsApiRequestTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).requestTransferOwnership(requestParameters.id, requestParameters.transferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Custodial Accounts only** - Signs the typed repositories value with types repositories structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
     * @summary Sign a given payload
     * @param {AccountsApiSignPayloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public signPayload(requestParameters: AccountsApiSignPayloadRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).signPayload(requestParameters.id, requestParameters.signPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a recovery process of a recoverable account.
     * @param {AccountsApiStartRecoveryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public startRecovery(requestParameters: AccountsApiStartRecoveryRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).startRecovery(requestParameters.id, requestParameters.startRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
     * @summary Sync account state with the blockchain
     * @param {AccountsApiSyncAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public syncAccount(requestParameters: AccountsApiSyncAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).syncAccount(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


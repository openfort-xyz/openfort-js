/* tslint:disable */
/* eslint-disable */
/**
 * Openfort API
 * Complete Openfort API references and guides can be found at: https://www.openfort.io/docs
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@openfort.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccountListResponse } from '../models';
// @ts-ignore
import { AccountResponse } from '../models';
// @ts-ignore
import { AccountResponseExpandable } from '../models';
// @ts-ignore
import { AccountV2Response } from '../models';
// @ts-ignore
import { BaseEntityListResponseAccountV2Response } from '../models';
// @ts-ignore
import { CancelTransferOwnershipRequest } from '../models';
// @ts-ignore
import { CompleteRecoveryRequest } from '../models';
// @ts-ignore
import { CreateAccountRequest } from '../models';
// @ts-ignore
import { DeployRequest } from '../models';
// @ts-ignore
import { SignPayloadRequest } from '../models';
// @ts-ignore
import { SignPayloadResponse } from '../models';
// @ts-ignore
import { SignerIdResponse } from '../models';
// @ts-ignore
import { SortOrder } from '../models';
// @ts-ignore
import { StartRecoveryRequest } from '../models';
// @ts-ignore
import { SwitchChainQueriesV2 } from '../models';
// @ts-ignore
import { TransactionIntentResponse } from '../models';
// @ts-ignore
import { TransferOwnershipRequest } from '../models';
/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferOwnership: async (id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelTransferOwnership', 'id', id)
            // verify required parameter 'cancelTransferOwnershipRequest' is not null or undefined
            assertParamExists('cancelTransferOwnership', 'cancelTransferOwnershipRequest', cancelTransferOwnershipRequest)
            const localVarPath = `/v1/accounts/{id}/cancel_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRecovery: async (id: string, completeRecoveryRequest: CompleteRecoveryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeRecovery', 'id', id)
            // verify required parameter 'completeRecoveryRequest' is not null or undefined
            assertParamExists('completeRecovery', 'completeRecoveryRequest', completeRecoveryRequest)
            const localVarPath = `/v1/accounts/{id}/complete_recovery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
         * @summary Deploy an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {DeployRequest} deployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAccount: async (id: string, deployRequest: DeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deployAccount', 'id', id)
            // verify required parameter 'deployRequest' is not null or undefined
            assertParamExists('deployAccount', 'deployRequest', deployRequest)
            const localVarPath = `/v1/accounts/{id}/deploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.  Returns the latest 10 transaction intents created by this account.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, expand?: Array<AccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountV2', 'id', id)
            const localVarPath = `/v2/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a player.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {number} [chainId] The chain ID. Must be a [supported chain](/development/chains).
         * @param {string} [player] Specifies the unique player ID (starts with pla_)
         * @param {string} [address] Specifies the address of the account
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (limit?: number, skip?: number, order?: SortOrder, chainId?: number, player?: string, address?: string, expand?: Array<AccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts for the given user.  This object represents a user\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a user.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {number} [chainId] The chain ID. Must be a [supported chain](/development/chains).
         * @param {string} [user] Specifies the unique user ID (starts with pla_)
         * @param {string} [chainType] The chain type. Must be either \&quot;EVM\&quot; or \&quot;SVM\&quot;.
         * @param {string} [accountType] Specifies the type of account. Must be either \&quot;Smart Account\&quot; or \&quot;Externally Owned Account\&quot;.
         * @param {string} [address] Specifies the account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsV2: async (limit?: number, skip?: number, order?: SortOrder, chainId?: number, user?: string, chainType?: string, accountType?: string, address?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (chainType !== undefined) {
                localVarQueryParameter['chainType'] = chainType;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignerIdByAddress: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getSignerIdByAddress', 'address', address)
            const localVarPath = `/v2/accounts/signer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferOwnership: async (id: string, transferOwnershipRequest: TransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestTransferOwnership', 'id', id)
            // verify required parameter 'transferOwnershipRequest' is not null or undefined
            assertParamExists('requestTransferOwnership', 'transferOwnershipRequest', transferOwnershipRequest)
            const localVarPath = `/v1/accounts/{id}/request_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Custodial Accounts only** - Signs the typed repositories value with types repositories structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload: async (id: string, signPayloadRequest: SignPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signPayload', 'id', id)
            // verify required parameter 'signPayloadRequest' is not null or undefined
            assertParamExists('signPayload', 'signPayloadRequest', signPayloadRequest)
            const localVarPath = `/v1/accounts/{id}/sign_payload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecovery: async (id: string, startRecoveryRequest: StartRecoveryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startRecovery', 'id', id)
            // verify required parameter 'startRecoveryRequest' is not null or undefined
            assertParamExists('startRecovery', 'startRecoveryRequest', startRecoveryRequest)
            const localVarPath = `/v1/accounts/{id}/start_recovery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SwitchChainQueriesV2} switchChainQueriesV2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchChainV2: async (switchChainQueriesV2: SwitchChainQueriesV2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'switchChainQueriesV2' is not null or undefined
            assertParamExists('switchChainV2', 'switchChainQueriesV2', switchChainQueriesV2)
            const localVarPath = `/v2/accounts/switch-chain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(switchChainQueriesV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('syncAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}/sync`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransferOwnership(id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransferOwnership(id, cancelTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeRecovery(id: string, completeRecoveryRequest: CompleteRecoveryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeRecovery(id, completeRecoveryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
         * @summary Deploy an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {DeployRequest} deployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployAccount(id: string, deployRequest: DeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployAccount(id, deployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.  Returns the latest 10 transaction intents created by this account.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV2(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV2(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a player.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {number} [chainId] The chain ID. Must be a [supported chain](/development/chains).
         * @param {string} [player] Specifies the unique player ID (starts with pla_)
         * @param {string} [address] Specifies the address of the account
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(limit?: number, skip?: number, order?: SortOrder, chainId?: number, player?: string, address?: string, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(limit, skip, order, chainId, player, address, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts for the given user.  This object represents a user\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a user.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {number} [chainId] The chain ID. Must be a [supported chain](/development/chains).
         * @param {string} [user] Specifies the unique user ID (starts with pla_)
         * @param {string} [chainType] The chain type. Must be either \&quot;EVM\&quot; or \&quot;SVM\&quot;.
         * @param {string} [accountType] Specifies the type of account. Must be either \&quot;Smart Account\&quot; or \&quot;Externally Owned Account\&quot;.
         * @param {string} [address] Specifies the account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsV2(limit?: number, skip?: number, order?: SortOrder, chainId?: number, user?: string, chainType?: string, accountType?: string, address?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEntityListResponseAccountV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsV2(limit, skip, order, chainId, user, chainType, accountType, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignerIdByAddress(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignerIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignerIdByAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTransferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTransferOwnership(id, transferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Custodial Accounts only** - Signs the typed repositories value with types repositories structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignPayloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signPayload(id, signPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecovery(id: string, startRecoveryRequest: StartRecoveryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRecovery(id, startRecoveryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SwitchChainQueriesV2} switchChainQueriesV2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async switchChainV2(switchChainQueriesV2: SwitchChainQueriesV2, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.switchChainV2(switchChainQueriesV2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {AccountsApiCancelTransferOwnershipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferOwnership(requestParameters: AccountsApiCancelTransferOwnershipRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.cancelTransferOwnership(requestParameters.id, requestParameters.cancelTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {AccountsApiCompleteRecoveryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRecovery(requestParameters: AccountsApiCompleteRecoveryRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.completeRecovery(requestParameters.id, requestParameters.completeRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
         * @summary Create an account object.
         * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(requestParameters: AccountsApiCreateAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.createAccount(requestParameters.createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
         * @summary Deploy an account.
         * @param {AccountsApiDeployAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAccount(requestParameters: AccountsApiDeployAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.deployAccount(requestParameters.id, requestParameters.deployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAccount(requestParameters: AccountsApiDisableAccountRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disableAccount(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.  Returns the latest 10 transaction intents created by this account.
         * @summary Get existing account.
         * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(requestParameters: AccountsApiGetAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.getAccount(requestParameters.id, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiGetAccountV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2(requestParameters: AccountsApiGetAccountV2Request, options?: AxiosRequestConfig): AxiosPromise<AccountV2Response> {
            return localVarFp.getAccountV2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a player.
         * @param {AccountsApiGetAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(requestParameters: AccountsApiGetAccountsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AccountListResponse> {
            return localVarFp.getAccounts(requestParameters.limit, requestParameters.skip, requestParameters.order, requestParameters.chainId, requestParameters.player, requestParameters.address, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts for the given user.  This object represents a user\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a user.
         * @param {AccountsApiGetAccountsV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsV2(requestParameters: AccountsApiGetAccountsV2Request = {}, options?: AxiosRequestConfig): AxiosPromise<BaseEntityListResponseAccountV2Response> {
            return localVarFp.getAccountsV2(requestParameters.limit, requestParameters.skip, requestParameters.order, requestParameters.chainId, requestParameters.user, requestParameters.chainType, requestParameters.accountType, requestParameters.address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiGetSignerIdByAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignerIdByAddress(requestParameters: AccountsApiGetSignerIdByAddressRequest, options?: AxiosRequestConfig): AxiosPromise<SignerIdResponse> {
            return localVarFp.getSignerIdByAddress(requestParameters.address, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {AccountsApiRequestTransferOwnershipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferOwnership(requestParameters: AccountsApiRequestTransferOwnershipRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.requestTransferOwnership(requestParameters.id, requestParameters.transferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * **Custodial Accounts only** - Signs the typed repositories value with types repositories structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
         * @summary Sign a given payload
         * @param {AccountsApiSignPayloadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload(requestParameters: AccountsApiSignPayloadRequest, options?: AxiosRequestConfig): AxiosPromise<SignPayloadResponse> {
            return localVarFp.signPayload(requestParameters.id, requestParameters.signPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {AccountsApiStartRecoveryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecovery(requestParameters: AccountsApiStartRecoveryRequest, options?: AxiosRequestConfig): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.startRecovery(requestParameters.id, requestParameters.startRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountsApiSwitchChainV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        switchChainV2(requestParameters: AccountsApiSwitchChainV2Request, options?: AxiosRequestConfig): AxiosPromise<AccountV2Response> {
            return localVarFp.switchChainV2(requestParameters.switchChainQueriesV2, options).then((request) => request(axios, basePath));
        },
        /**
         * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
         * @summary Sync account state with the blockchain
         * @param {AccountsApiSyncAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAccount(requestParameters: AccountsApiSyncAccountRequest, options?: AxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.syncAccount(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelTransferOwnership operation in AccountsApi.
 * @export
 * @interface AccountsApiCancelTransferOwnershipRequest
 */
export interface AccountsApiCancelTransferOwnershipRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiCancelTransferOwnership
     */
    readonly id: string

    /**
     * 
     * @type {CancelTransferOwnershipRequest}
     * @memberof AccountsApiCancelTransferOwnership
     */
    readonly cancelTransferOwnershipRequest: CancelTransferOwnershipRequest
}

/**
 * Request parameters for completeRecovery operation in AccountsApi.
 * @export
 * @interface AccountsApiCompleteRecoveryRequest
 */
export interface AccountsApiCompleteRecoveryRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiCompleteRecovery
     */
    readonly id: string

    /**
     * 
     * @type {CompleteRecoveryRequest}
     * @memberof AccountsApiCompleteRecovery
     */
    readonly completeRecoveryRequest: CompleteRecoveryRequest
}

/**
 * Request parameters for createAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateAccountRequest
 */
export interface AccountsApiCreateAccountRequest {
    /**
     * 
     * @type {CreateAccountRequest}
     * @memberof AccountsApiCreateAccount
     */
    readonly createAccountRequest: CreateAccountRequest
}

/**
 * Request parameters for deployAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeployAccountRequest
 */
export interface AccountsApiDeployAccountRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiDeployAccount
     */
    readonly id: string

    /**
     * 
     * @type {DeployRequest}
     * @memberof AccountsApiDeployAccount
     */
    readonly deployRequest: DeployRequest
}

/**
 * Request parameters for disableAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDisableAccountRequest
 */
export interface AccountsApiDisableAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsApiDisableAccount
     */
    readonly id: string
}

/**
 * Request parameters for getAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRequest
 */
export interface AccountsApiGetAccountRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiGetAccount
     */
    readonly id: string

    /**
     * 
     * @type {Array<AccountResponseExpandable>}
     * @memberof AccountsApiGetAccount
     */
    readonly expand?: Array<AccountResponseExpandable>
}

/**
 * Request parameters for getAccountV2 operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountV2Request
 */
export interface AccountsApiGetAccountV2Request {
    /**
     * 
     * @type {string}
     * @memberof AccountsApiGetAccountV2
     */
    readonly id: string
}

/**
 * Request parameters for getAccounts operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountsRequest
 */
export interface AccountsApiGetAccountsRequest {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof AccountsApiGetAccounts
     */
    readonly limit?: number

    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof AccountsApiGetAccounts
     */
    readonly skip?: number

    /**
     * Specifies the order in which to sort the results.
     * @type {SortOrder}
     * @memberof AccountsApiGetAccounts
     */
    readonly order?: SortOrder

    /**
     * The chain ID. Must be a [supported chain](/development/chains).
     * @type {number}
     * @memberof AccountsApiGetAccounts
     */
    readonly chainId?: number

    /**
     * Specifies the unique player ID (starts with pla_)
     * @type {string}
     * @memberof AccountsApiGetAccounts
     */
    readonly player?: string

    /**
     * Specifies the address of the account
     * @type {string}
     * @memberof AccountsApiGetAccounts
     */
    readonly address?: string

    /**
     * Specifies the fields to expand in the response.
     * @type {Array<AccountResponseExpandable>}
     * @memberof AccountsApiGetAccounts
     */
    readonly expand?: Array<AccountResponseExpandable>
}

/**
 * Request parameters for getAccountsV2 operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountsV2Request
 */
export interface AccountsApiGetAccountsV2Request {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof AccountsApiGetAccountsV2
     */
    readonly limit?: number

    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof AccountsApiGetAccountsV2
     */
    readonly skip?: number

    /**
     * Specifies the order in which to sort the results.
     * @type {SortOrder}
     * @memberof AccountsApiGetAccountsV2
     */
    readonly order?: SortOrder

    /**
     * The chain ID. Must be a [supported chain](/development/chains).
     * @type {number}
     * @memberof AccountsApiGetAccountsV2
     */
    readonly chainId?: number

    /**
     * Specifies the unique user ID (starts with pla_)
     * @type {string}
     * @memberof AccountsApiGetAccountsV2
     */
    readonly user?: string

    /**
     * The chain type. Must be either \&quot;EVM\&quot; or \&quot;SVM\&quot;.
     * @type {string}
     * @memberof AccountsApiGetAccountsV2
     */
    readonly chainType?: string

    /**
     * Specifies the type of account. Must be either \&quot;Smart Account\&quot; or \&quot;Externally Owned Account\&quot;.
     * @type {string}
     * @memberof AccountsApiGetAccountsV2
     */
    readonly accountType?: string

    /**
     * Specifies the account address
     * @type {string}
     * @memberof AccountsApiGetAccountsV2
     */
    readonly address?: string
}

/**
 * Request parameters for getSignerIdByAddress operation in AccountsApi.
 * @export
 * @interface AccountsApiGetSignerIdByAddressRequest
 */
export interface AccountsApiGetSignerIdByAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsApiGetSignerIdByAddress
     */
    readonly address: string
}

/**
 * Request parameters for requestTransferOwnership operation in AccountsApi.
 * @export
 * @interface AccountsApiRequestTransferOwnershipRequest
 */
export interface AccountsApiRequestTransferOwnershipRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiRequestTransferOwnership
     */
    readonly id: string

    /**
     * 
     * @type {TransferOwnershipRequest}
     * @memberof AccountsApiRequestTransferOwnership
     */
    readonly transferOwnershipRequest: TransferOwnershipRequest
}

/**
 * Request parameters for signPayload operation in AccountsApi.
 * @export
 * @interface AccountsApiSignPayloadRequest
 */
export interface AccountsApiSignPayloadRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiSignPayload
     */
    readonly id: string

    /**
     * 
     * @type {SignPayloadRequest}
     * @memberof AccountsApiSignPayload
     */
    readonly signPayloadRequest: SignPayloadRequest
}

/**
 * Request parameters for startRecovery operation in AccountsApi.
 * @export
 * @interface AccountsApiStartRecoveryRequest
 */
export interface AccountsApiStartRecoveryRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiStartRecovery
     */
    readonly id: string

    /**
     * 
     * @type {StartRecoveryRequest}
     * @memberof AccountsApiStartRecovery
     */
    readonly startRecoveryRequest: StartRecoveryRequest
}

/**
 * Request parameters for switchChainV2 operation in AccountsApi.
 * @export
 * @interface AccountsApiSwitchChainV2Request
 */
export interface AccountsApiSwitchChainV2Request {
    /**
     * 
     * @type {SwitchChainQueriesV2}
     * @memberof AccountsApiSwitchChainV2
     */
    readonly switchChainQueriesV2: SwitchChainQueriesV2
}

/**
 * Request parameters for syncAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiSyncAccountRequest
 */
export interface AccountsApiSyncAccountRequest {
    /**
     * Specifies the unique account ID (starts with acc_).
     * @type {string}
     * @memberof AccountsApiSyncAccount
     */
    readonly id: string
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Cancel a pending transfer of ownership.
     * @summary Cancel request to transfer ownership of an account.
     * @param {AccountsApiCancelTransferOwnershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public cancelTransferOwnership(requestParameters: AccountsApiCancelTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).cancelTransferOwnership(requestParameters.id, requestParameters.cancelTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete a recovery process of a recoverable account.
     * @param {AccountsApiCompleteRecoveryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public completeRecovery(requestParameters: AccountsApiCompleteRecoveryRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).completeRecovery(requestParameters.id, requestParameters.completeRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
     * @summary Create an account object.
     * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(requestParameters: AccountsApiCreateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(requestParameters.createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
     * @summary Deploy an account.
     * @param {AccountsApiDeployAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deployAccount(requestParameters: AccountsApiDeployAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deployAccount(requestParameters.id, requestParameters.deployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiDisableAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public disableAccount(requestParameters: AccountsApiDisableAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).disableAccount(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.  Returns the latest 10 transaction intents created by this account.
     * @summary Get existing account.
     * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(requestParameters: AccountsApiGetAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(requestParameters.id, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiGetAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountV2(requestParameters: AccountsApiGetAccountV2Request, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountV2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
     * @summary List accounts of a player.
     * @param {AccountsApiGetAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(requestParameters: AccountsApiGetAccountsRequest = {}, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(requestParameters.limit, requestParameters.skip, requestParameters.order, requestParameters.chainId, requestParameters.player, requestParameters.address, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts for the given user.  This object represents a user\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  Returns the latest 10 transaction intents for each account.  By default, a maximum of 10 accounts are shown per page.
     * @summary List accounts of a user.
     * @param {AccountsApiGetAccountsV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountsV2(requestParameters: AccountsApiGetAccountsV2Request = {}, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountsV2(requestParameters.limit, requestParameters.skip, requestParameters.order, requestParameters.chainId, requestParameters.user, requestParameters.chainType, requestParameters.accountType, requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiGetSignerIdByAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getSignerIdByAddress(requestParameters: AccountsApiGetSignerIdByAddressRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getSignerIdByAddress(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
     * @summary Request transfer ownership of account.
     * @param {AccountsApiRequestTransferOwnershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public requestTransferOwnership(requestParameters: AccountsApiRequestTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).requestTransferOwnership(requestParameters.id, requestParameters.transferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Custodial Accounts only** - Signs the typed repositories value with types repositories structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
     * @summary Sign a given payload
     * @param {AccountsApiSignPayloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public signPayload(requestParameters: AccountsApiSignPayloadRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).signPayload(requestParameters.id, requestParameters.signPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a recovery process of a recoverable account.
     * @param {AccountsApiStartRecoveryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public startRecovery(requestParameters: AccountsApiStartRecoveryRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).startRecovery(requestParameters.id, requestParameters.startRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountsApiSwitchChainV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public switchChainV2(requestParameters: AccountsApiSwitchChainV2Request, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).switchChainV2(requestParameters.switchChainQueriesV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
     * @summary Sync account state with the blockchain
     * @param {AccountsApiSyncAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public syncAccount(requestParameters: AccountsApiSyncAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).syncAccount(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}

